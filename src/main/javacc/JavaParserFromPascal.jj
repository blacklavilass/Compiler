options {
    LOOKAHEAD = 2;
    STATIC = false;
}

PARSER_BEGIN(JavaParserFromPascal)

import java.util.ArrayList;
import java.util.List;
import nodes.BinaryOperator;import nodes.VariableNameNode;import printer.*;
import nodes.*;
public class JavaParserFromPascal {

    public static void main(String[] args) throws Exception {
        JavaParserFromPascal parser = new JavaParserFromPascal(System.in);
        ListNode nodes = parser.start();
        System.out.println("Парсинг завершен!");
        System.out.println(Printer.printTree(nodes.tree(), "\n"));
    }

}

}
PARSER_END(JavaParserFromPascal)

SKIP : { " " | "\t" | "\n" | "\r" | <"{" (~["}"])* "}"> | <"//" (~["\n"])* "\n">}

TOKEN : { < EMPTY: "" > |
    < IF: "if" > |
    < ELSE: "else" > |
    < FOR: "for" > |
    < WHILE: "while" > |
    < VAR: "var" > |
    < RESULT: "Result" > | /*TODO подумоть над ризалт*/
    < THEN: "then" > | < DO: "do" > |
    < KEYWORD: <IF> | <ELSE> | <FOR> | <WHILE> | <RESULT> | <VAR> | <THEN> | <DO> >|
    < NUM: (["+","-"])? (["0"-"9"])+ ("." (["0"-"9"])+)? (["e","E"] (["+","-"])? (["0"-"9"])+)? > |
    < STR: "'" (~["'"])* "'" > |
    < TRUE: "true" > | < FALSE: "false" > |
    < LITERAL: <NUM> | <STR> | <TRUE> | <FALSE> > |
    < TYPE: "integer" | "real" | "string" | "boolean" | "char" > |
    < LPAR: "(" > | < RPAR: ")" > |
    < LBRACK: "[" > | < RBRACK: "]" > |
    < BEGIN: "begin" > | < END: "end" > |
    < SEMI: ";" > | < COMMA: "," > | <COLON: ":"> |
    < ASSIGN: ":=" > |
    < ADD: "+" > | < SUB: "-" > |
    < MUL: "*" > | < DIVISION: "/" > | < MOD: "mod" > | < DIV: "div" > |
    < AND: "and" > | < OR: "or" > |
    < NOT: "not" > |
    < GE: ">=" > | < LE: "<=" > |
    < GT: ">" > | < LT: "<" > |
    < NEQUALS: "<>" > | < EQUALS: "=" > |
    < VARAIBLE_NAME: (["a"-"z","A"-"Z","_"]) (["a"-"z","A"-"Z","_","0"-"9"])* >}

public ListNode start(): {
    List<VarNode> n;
} {
    n=program()
    {return new ListNode(n);}
}

List<VarNode> program(): {
    VarNode var;
    List<VarNode> vars = new ArrayList<>();
} {
    var = var() {vars.add(var);} <EOF>
    {return vars;}
}

VarNode var() : {
VarLineNode n;
List<VarLineNode> lines = new ArrayList<>();
} {
(n = varLine() {lines.add(n);})+
{return new VarNode(lines);}
}

VarLineNode varLine() : {
VariableNameNode n;
List<VariableNameNode> names = new ArrayList<>();
TypeNode tn;
} {
n=variableName() {names.add(n);} (<COMMA> n=variableName() {names.add(n);})* <COLON> tn = type() <SEMI>
{return new VarLineNode(names, tn);}
}

//Program operation=============================================================================================

CallNode call(): {
    VariableNameNode n1;
    ExprNode n2;
    List<ExprNode> nList = new ArrayList<>();
} {
   n1=variableName() <LPAR> (LOOKAHEAD(1) n2=expr() {nList.add(n2);} (<COMMA> n2=expr() {nList.add(n2);})*)? <RPAR>
   {return new CallNode(n1, nList);}
}

AssignNode assign(): {
    IdentNode n1;
    ExprNode n2;
    Token t;
} {
    n1=variableName() <ASSIGN> n2=expr()
    {return new AssignNode(n1, n2);}
}

StmtNode simpleStmt(): {
    StmtNode n;
} {
    (n=assign() | n=call()) <SEMI>
    {return n;}
}

IfNode if_(): {
    ExprNode n1;
    StmtNode n2;
    StmtNode n3 = null;
} {
    <IF> <LPAR> n1=expr() <RPAR> n2=stmt() (<ELSE> n3=stmt())?
    {
if (n3 == null)
    return new IfNode(n1, n2);
else
    return new IfElseNode(n1, n2, n3);
    }
}

StmtListNode forStmtList0(): {
    StmtNode n;
    List<StmtNode> nList = new ArrayList<>();
} {
    (n=simpleStmt() {nList.add(n);} (<COMMA> n=simpleStmt() {nList.add(n);})*)?
    {return new StmtListNode(nList);}
}

StmtNode forStmtList(): {
    StmtNode n;
} {
    (n=vars() | n=forStmtList0())
    {return n;}
}

ExprNode forCond(): {
    ExprNode n;
} {
    (n=expr() | <EMPTY> {n=new StmtListNode(new ArrayList<>());})
    {return n;}
}

StmtNode forBody(): {
    StmtNode n;
} {
    (n=stmt() | <SEMI> {n=new StmtListNode(new ArrayList<>());})
    {return n;}
}

WhileNode while_(): {
    ExprNode n1;
    StmtNode n2;
} {
    <WHILE> <LPAR> n1=expr() <RPAR> n2=stmt()
    {return new WhileNode(n1, n2);}
}

ForNode for_(): {
    StmtNode n1;
    ExprNode n2;
    StmtNode n3;
    StmtNode n4;
} {
    <FOR> <LPAR> n1=forStmtList() <SEMI> n2=forCond() <SEMI> n3=forStmtList() <RPAR> n4=forBody()
    {return new ForNode(n1, n2, n3, n4);}
}

VarDeclarationNode varDeclaration(): {
    TypeNode n1;
    ExprNode n2;
    List<ExprNode> nList = new ArrayList<>();
} {
    n1=type() n2=varInner() {nList.add(n2);} (<COMMA> n2=varInner() {nList.add(n2);})*
    {return new VarsNode(n1, nList);}
}

StmtNode stmt(): {
    StmtNode n;
} {
    (n=if_() | n=while_() | n=for_() | n=simpleStmt() | LOOKAHEAD(3) n=varDeclaration() <SEMI> | n=composite() | n=func())
    {return n;}
}

//math=============================================================================================

ExprNode mult(): {
    ExprNode n1;
    ExprNode n2;
    Token t;
} {
    n1=group() ((t=<MUL> | t=<DIV> | t=<MOD> | t=<DIVISION>) n2=group() {n1 = new BinOpNode(BinaryOperator.fromString(t.toString()), n1, n2);})*
    {return n1;}
}

ExprNode add(): {
    ExprNode n1;
    ExprNode n2;
    Token t;
} {
    n1=mult() ((t=<ADD> | t=<SUB>) n2=mult() {n1 = new BinOpNode(BinaryOperator.fromString(t.toString()), n1, n2);})*
    {return n1;}
}

ExprNode compare(): {
    ExprNode n1;
    ExprNode n2;
    Token t;
} {
    n1=add() ((t=<GE> | t=<LE> | t=<GT> | t=<LT> | t=<EQUALS> | t=<NEQUALS>) n2=add() {n1 = new BinOpNode(BinaryOperator.fromString(t.toString()), n1, n2);})?
    {return n1;}
}

ExprNode logicalAnd(): {
    ExprNode n1;
    ExprNode n2;
    Token t;
} {
    n1=compare() (t=<AND> n2=compare() {n1 = new BinOpNode(BinaryOperator.fromString(t.toString()), n1, n2);})*
    {return n1;}
}

ExprNode logicalOr(): {
    ExprNode n1;
    ExprNode n2;
    Token t;
} {
    n1=logicalAnd() (t=<OR> n2=logicalAnd() {n1 = new BinOpNode(BinaryOperator.fromString(t.toString()), n1, n2);})*
    {return n1;}
}

ExprNode expr(): {
   ExprNode n;
} {
   n=logicalOr()
   {return n;}
}

ExprNode group(): {
   ExprNode n;
} {
   (n=literal() | n=call() | n=variableName() | <LPAR> n=expr() <RPAR>)
   {return n;}
}

//basics=============================================================================================

LiteralNode literal(): {
    Token t;
} {
    (t=<NUM> | t=<TRUE> | t=<FALSE> | t=<STR>)
    {return new LiteralNode(t.toString());}
}

VariableNameNode variableName() : {
Token t;
} {
t = <VARAIBLE_NAME>
{
return new VariableNameNode(t.toString());}
}

TypeNode type() : {
Token t;
} {
t = <TYPE>
{return new TypeNode(t.toString());}
}

LiteralNode num(): {
    Token t;
} {
    t=<NUM>
    {return new LiteralNode(t.toString());}
}

LiteralNode str(): {
    Token t;
} {
    t=<STR>
    {return new LiteralNode(t.toString());}
}

/*StmtListNode stmtList(): {
   List<StmtNode> nList = new ArrayList<>();
   StmtNode n;
} {
    (n=stmt() {nList.add(n);} (<SEMI>)*)*
   {return new StmtListNode(nList);}
}*/

/*
public StmtListNode start(): {
    StmtListNode n;
} {
    n=program()
    {return n;}
}

StmtListNode program(): {
    StmtListNode n;
} {
    n=stmtList() <EOF>
    {return n;}
}

ReturnNode return_(): {
    ExprNode n;
} {
    <RETURN> n=expr()
    {return new ReturnNode(n);}
}

StmtListNode composite(): {
    StmtListNode n;
} {
     <LBRACE> n=stmtList() <RBRACE>
    {return n;}
}

ParamNode param(): {
    TypeNode n1;
    IdentNode n2;
} {
    n1=type() n2=ident()
    {return new ParamNode(n1, n2);}
}

List<ParamNode> params(): {
    ParamNode n;
    List<ParamNode> nList = new ArrayList<>();
} {
    (n=param() {nList.add(n);} (<COMMA> n=param() {nList.add(n);})*)?
    {return nList;}
}

FuncNode func(): {
    TypeNode n1;
    IdentNode n2;
    List<ParamNode> nList;
    StmtNode n3;
} {
    n1=type() n2=ident() <LPAR> nList=params() <RPAR> <LBRACE> n3=stmtList() <RBRACE>
    {return new FuncNode(n1, n2, nList, n3);}
}*/
